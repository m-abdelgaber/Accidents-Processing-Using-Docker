import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt
from datetime import datetime, timedelta
from scipy import stats
from sklearn import preprocessing
from sklearn.neighbors import LocalOutlierFactor
import csv

def milestone1(uncleaned_data_path, cleaned_data_output_path, lookup_table_output_path):
    path = uncleaned_data_path
    data = pd.read_csv(path)
    # data = pd.read_parquet(path, engine='pyarrow')

    index_col = "accident_index"
    data = data.set_index('accident_index')
    # data = data.replace('nan', np.nan)

    """some functions"""

    # def get_percentage(data):
    #     display(data.isnull().sum()/len(data)*100)

    """# 2- EDA

    ## General exploring
    """

    data.head()

    data.shape

    data.info()

    """
    percentage of rows that are nulls

    we can notice here that the empty columns are:
    longitude
    latitude

    a huge chunk of data is missing from:
    second_road_number

    less than 1% percent of the data is missing from:
    location_easting_osgr
    location_northing_osgr
    date
    time
    first_road_number
    road_type
    weather_conditions
    """

    # get_percentage(data)

    """
    single value columns (std =0 in numerical cols or unique =1 in non-numerical cols) are:
    accident_year = 1990 (dropped)
    longitude = NaN (dropped)
    latitude = NaN (dropped)
    local_authority_ons_district = -1 (dropped)
    local_authority_highway = -1 (dropped)
    lsoa_of_accident_location = -1 (dropped)
    urban_or_rural_area = Data missing or out of range (dropped)
    did_police_officer_attend_scene_of_accident = Data missing or out of range (dropped)
    trunk_road_flag = Data missing or out of range (dropped)

    columns with no duplicates (unique = number of rows in non-numerical cols) are:
    accident_index
    accident_reference

    columns where there's a possibility for outliers (max is far away from the 75% quartile in numerical cols) are:
    number_of_vehicles
    number_of_casualties
    speed_limit
    """
    data.describe(include = np.number)

    data.describe(include = np.object).iloc[:,:len(data.columns)//2]

    data.describe(include = np.object).iloc[:,:len(data.columns)//2]

    print(data.apply(lambda col: col.unique()))

    data.corr()

    """## Initial cleaning just to have more meaningful EDA"""

    columns_to_drop = ["accident_reference","longitude", "latitude", "second_road_number", "accident_year", "local_authority_ons_district", "local_authority_highway", "lsoa_of_accident_location",\
                    "urban_or_rural_area", "did_police_officer_attend_scene_of_accident", "trunk_road_flag"]
    df_EDA = data.drop(columns= columns_to_drop, axis=1)
    df_EDA = df_EDA.dropna()
    df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})
    df_EDA['date'] = pd.to_datetime(df_EDA["date"])
    df_EDA.location_easting_osgr = df_EDA.location_easting_osgr.astype(np.float64)
    df_EDA.location_northing_osgr = df_EDA.location_northing_osgr.astype(np.float64)
    df_EDA.number_of_vehicles = df_EDA.number_of_vehicles.astype(np.float64)
    df_EDA.number_of_casualties = df_EDA.number_of_casualties.astype(np.float64)

    # df_EDA['day_of_week'] = df_EDA.day_of_week.map({'Sunday':0, 'Monday':1, 'Tuesday':2, "Wednesday":3, "Thursday": 4, "Friday":5, "Saturday":6})

    #added feature
    df_EDA['month'] = df_EDA['date'].dt.month
    df_EDA['Week'] = df_EDA['date'].dt.week
    df_EDA['day'] = df_EDA['date'].dt.day
    df_EDA['time'] = pd.to_datetime(df_EDA["time"])
    df_EDA['hour'] = df_EDA['time'].dt.hour
    df_EDA['minute'] = df_EDA['time'].dt.minute

    df_EDA.info()

    df_EDA.shape

    df_EDA.head()

    """from the correlation matrix and heatmap we can see there's a strong positive correlation between month and week (the new columns we added for the EDA phase), medium negative correlation between location_eastern_osgr and location_northing_osgr and a slight positive correlation betwee:
    1. number of casualties and speed limit
    2. number of casualties and accident severity
    3. speed limit and accident severity
    4. number of vehicles and speed limit
    5. number of casualities and number of vehicles
    """

    df_EDA.corr()

    # plt.figure(figsize=(14,7))
    # sns.heatmap(df_EDA.corr(), annot=True, cmap="YlGnBu", vmin=-1, vmax=1, linewidths=.2)

    """the histogeam of the numeric features shows some of the features like the date and its parts( month, week, day) are equally distributed. 

    Some other features are norally distributed like time and its parts (hour, minute)

    The rest of the features are skewed 
    """

    # df_EDA.hist(figsize=(30,12))

    #!!!! Don't run this cell again it takes 15 minutes
    # sns.pairplot(df_EDA, hue="accident_severity")

    """## Questions and Visualizations

    ### Question 1: what is the relation between the accident severity and the number of vehicles?

    Answer: There's no significant correlation between accident severity classes and the average of the number of vehicles. All Accidents classes have an average of 1.7 cars in them approximately.
    """

    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({0:'Slight', 1:'Serious', 2:'Fatal'})
    # chart = sns.catplot(data=df_EDA, x="accident_severity", y="number_of_vehicles", kind= 'bar')
    # plt.ylabel("average number of vehicles")
    # plt.xlabel("accident severity")
    # plt.show(chart)
    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})

    """### Question 2: Does the number of casualties increase with the increase in accidents severity?

    Answer: Yes, with the increase of accident severity, the average number of casualties increase. The casualties are approximately 1.25 in slight accidents, 1.5 in serious accidents and 2 in Fatal accidents
    """

    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({0:'Slight', 1:'Serious', 2:'Fatal'})
    # chart = sns.catplot(x = 'accident_severity',\
    #             y = 'number_of_casualties',\
    #             data = df_EDA,
    #             kind = "bar")
    # plt.ylabel("average number of casualties")
    # plt.xlabel("accident severity")
    # plt.show(chart)
    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})

    """### Question 3: What is the relation between the number of accidents and the hour of the day

    Answer: accidents happen the most from 03:00 pm to 06:00 pm and around 08:00 am. That might be the case because these are rush hours when people are heading to work/school at the morning and returning home after work/school is finished. Accidents are scarce around 04:00 am. This might be the case becuase people might be sleeping at this time.
    """

    # chart = sns.countplot(x ='hour', data = df_EDA)
    # plt.xlabel("hour of the day")
    # plt.ylabel("number of accidents")
    # plt.show(chart)

    """### Question 4: What is the relation between the number of accidents and the day of the week?

    Friday is the day with the most accidents and sunday is the day with the least accidents. This might be the case because Friday is the last working day and because Sunday is a part of the weekend. This doesn't explain however why Saturday has a high number of accidents although it's a weekend? Maybe people in UK like to go out and party on Saturdays: https://www.quora.com/Why-do-US-and-UK-people-go-out-party-on-Friday-and-not-on-Saturdays-like-the-rest-of-Europe
    """

    # chart = sns.countplot(x ='day_of_week', data = df_EDA,  order= ['Monday', "Tuesday", 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'])
    # chart.set_xticklabels(chart.get_xticklabels(),  rotation=45)
    # plt.xlabel("day of the week")
    # plt.ylabel("number of accidents")
    # plt.show(chart)

    """### Question 5: What is the relation between the number of accidents and the month?

    Answer: accidents happen slightly more in January and october, but overall there doesn't seem to be a significant relation between the month and number of accidents.
    """

    # chart = sns.countplot(x ='month', data = df_EDA)
    # plt.xlabel("month")
    # plt.ylabel("number of accidents")
    # plt.show(chart)

    """### Question 6: How are accidents distributed on the map?

    The plot shows the distribution. We can see that the lots of Serious and Slight accidents happen at certain points especially around London

    ![uk (1).gif](data:image/gif;base64,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)
    """

    df_EDA['accident_severity'] = df_EDA.accident_severity.map({0:'Slight', 1:'Serious', 2:'Fatal'})
    sns.jointplot(data=df_EDA, x="location_easting_osgr", y="location_northing_osgr" ,hue = "accident_severity")
    df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})

    """### Question 7: what is the relation between accident weather, light and road conditions, and the number of accidents?

    #### Question 7.1: what is the relation between weather condition and the number of accidents?
    """

    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({0:'Slight', 1:'Serious', 2:'Fatal'})
    # chart = sns.countplot(y ='weather_conditions', data = df_EDA, hue= 'accident_severity' )
    # chart.set_yticklabels(chart.get_yticklabels())
    # chart.set_xscale('log')
    # plt.xlabel("number of accidents")
    # plt.ylabel("weather conditions")
    # plt.show(chart)
    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})

    """#### Question 7.2: what is the relation between light conditions and the number of accidents?"""

    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({0:'Slight', 1:'Serious', 2:'Fatal'})
    # chart = sns.countplot(y ='light_conditions', data = df_EDA , hue = 'accident_severity')
    # chart.set_yticklabels(chart.get_yticklabels())
    # chart.set_xscale('log')
    # plt.xlabel("number of accidents")
    # plt.ylabel("light conditions")
    # plt.show(chart)
    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})

    """#### Question 7.3: what is the relation between road surface conditions and the number of accidents and their severity?"""

    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({0:'Slight', 1:'Serious', 2:'Fatal'})
    # chart = sns.countplot(y ='road_surface_conditions', data = df_EDA , hue='accident_severity')
    # chart.set_yticklabels(chart.get_yticklabels())
    # chart.set_xscale('log')
    # plt.xlabel("number of accidents")
    # plt.ylabel("road surface conditions")
    # plt.show(chart)
    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})

    """#### Question 7.4: what is the relation between carriageway hazards and the number of accidents?"""

    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({0:'Slight', 1:'Serious', 2:'Fatal'})
    # chart = sns.countplot(y ='carriageway_hazards', data = df_EDA, hue= 'accident_severity' )
    # chart.set_yticklabels(chart.get_yticklabels())
    # chart.set_xscale('log')
    # plt.xlabel("number of accidents")
    # plt.ylabel("carriageway hazards")
    # plt.show(chart)
    # df_EDA['accident_severity'] = df_EDA.accident_severity.map({'Slight':0, 'Serious':1, 'Fatal':2})

    """# 3 - Cleaning Data

    ## Observing Missing and duplicate Data

    ### NaN Values
    *Data missing with NaN Values*
    """

    data.info()

    # get_percentage(data)

    """#### MCAR missing

    **location_easting_osgr and location_northing_osgr**

    The values missing here don't have a systemic relationship with any other feature and the data itself doesn't explain why they're missing

    **time**

    The values missing here don't have a systemic relationship with any other feature and the data itself doesn't explain why they're missing

    **road_type**

    The values missing here don't have a systemic relationship with any other feature and the data itself doesn't explain why they're missing

    **first_road_number**

    The values missing here don't have a systemic relationship with any other feature and the data itself doesn't explain why they're missing

    **weather_conditions**
    The values missing here don't have a systemic relationship with any other feature and the data itself doesn't explain why they're missing

    #### MAR

    **Longitude and Latitude**

    are missing because another navigation system was used "BNG" that uses easting and northing values and their values can be obtained from the other features

    **second_road_number**

    can be infered from second road class when second raod class == -1
    when not junction exists and there's only first road then second road doesn't exist so second road class --1 and its number is NaN
    """

    data[data.second_road_class == '-1'].second_road_number.isna()
    print("percentage of data where second road class =-1 and second road number = NaN: ",len(data[data.second_road_class == '-1'].second_road_number.isna())/ len(data)*100)

    """### Non Nan Values

    *Data missing but has Values of "Missing Data" in Cell*
    """

    for (columnName,columnData) in data.iteritems():
        if data[columnName].dtypes == object:
            missing = data[data[columnName].str.contains("missing", na=False)]
            percentage = len(missing)/len(data)*100
            if percentage>0:
                print(columnName, data.shape, percentage)

    """urban_or_rural_area, did_police_officer_attend_scene_of_accident,trunk_road_flag. All values in these columns are missing.

    junction_control:MAR

    Explanation: Some accindents happened in places where is no junction.

    The Rest are MCAR as there is no pattern what explains why they are missing.

    ## Handling Missing data
    """

    #before dropping
    print(data.shape)
    data

    """**Dropping columns with single values that are non NaN**"""

    #after dropping #1

    columns_freq=data.describe(include = 'all')
    columns_with_one_unique_value=[]
    for (columnName, columnData) in columns_freq.iteritems():
    # print(columnName, columnData.values[1], columnData.values[6], columnData.values[10])
        if(columnData.values[1]==1):#with 1 unique value
            columns_with_one_unique_value.append(columnName)
        if(columnData.values[6]==columnData.values[10]):#min=max
            columns_with_one_unique_value.append(columnName)
    # print(columns_with_one_unique_value)
    data_clean=data.drop(columns_with_one_unique_value,axis=1)
    print("dropped columns are", columns_with_one_unique_value)
    print(data_clean.shape)
    data_clean

    """**dropping columns with at least 50% of their values as NaN**"""

    columns_percentage=data.isnull().sum()/len(data)*100
    columns_to_drop=[]
    for i in range(len(columns_percentage)):
        if(columns_percentage[i]>50): 
            columns_to_drop.append(columns_percentage.index[i])
    data_clean=data_clean.drop(columns_to_drop,axis=1)
    print("dropped columns are", columns_to_drop)

    print(data_clean.shape)
    data_clean

    """*dropping rows with NaN values of the MCAR data type*"""

    print('before dropping \n')
    print(data_clean.shape)
    # get_percentage(data_clean)

    columns_percentage_new=data_clean.isnull().sum()/len(data)*100
    rows_to_drop=[]
    for i in range(len(columns_percentage_new)):
        if(columns_percentage_new[i]<3): 
            rows_to_drop.append(columns_percentage_new.index[i])
    data_clean=data_clean.dropna(subset=rows_to_drop)
    print('after dropping \n')
    print(data_clean.shape)
    # get_percentage(data_clean)

    """*Dealing with first_road_number*"""

    data_clean.first_road_number.value_counts()

    data_clean.loc[data_clean.first_road_number == "first_road_class is C or Unclassified. These roads do not have official numbers so recorded as zero ",'first_road_number']="0.0"
    data_clean.first_road_number.value_counts()

    """*Dealing with second_road_class by providing consistency through replacing -1 with Unavailable*"""

    data_clean.second_road_class.value_counts()

    data_clean.loc[data_clean.second_road_class == "-1",'second_road_class']="Unavailable"
    data_clean.second_road_class.value_counts()

    """*Dealing with second_road_number*"""

    data_clean['second_road_number'].value_counts()

    data_clean = data_clean.fillna(value= "Unavailable", axis = 0)
    data_clean['second_road_number'].value_counts()

    data_clean.loc[data_clean.second_road_number == "first_road_class is C or Unclassified. These roads do not have official numbers so recorded as zero ",'second_road_number']="0.0"
    data_clean.second_road_number.value_counts()

    data_clean.shape

    data_clean["accident_reference"].nunique()

    """**Replacing Missing Data with Mode**

    replacing Data missing or out of range of feature special_conditions_at_site with the mode of the same feature

    why this technique? 
    we used the mode to replace the missing values with the most frequent value in that feature

    **Special case: Weather Conditions**

    we thought about nominal inputation of weather condtition using the mode of the weather condition in specific seasons
    """

    def season_of_date(date):
        date_form=pd.to_datetime(date)
        doy = date_form.dayofyear
        # "day of year" ranges for the northern hemisphere
        spring = range(80, 172)
        summer = range(172, 264)
        fall = range(264, 355)
        # winter = everything else
        if doy in spring:
            return 'spring'
        elif doy in summer:
            return 'summer' 
        elif doy in fall:
            return 'fall'
        else:
            return 'winter'

    """we created the season feature to replacae the data missing or out of range value of Weather Conditions feature based on the mode of observations with the same season feature"""

    data_clean['Season'] = data_clean.date.map(season_of_date)

    print("before\n")
    data_clean.weather_conditions.value_counts()

    print("the most frequent weather condition at spring season on top \n")
    data_clean[data_clean.Season == "spring"].weather_conditions.value_counts()

    print("the most frequent weather condition at summer season on top \n")
    data_clean[data_clean.Season == "summer"].weather_conditions.value_counts()

    print("the most frequent weather condition at summer winter on top \n")
    data_clean[data_clean.Season == "winter"].weather_conditions.value_counts()

    print("the most frequent weather condition at fall season on top \n")
    data_clean[data_clean.Season == "fall"].weather_conditions.value_counts()

    mode = data_clean.weather_conditions.value_counts().index[0]
    data_miss = 'Data missing or out of range'

    data_clean.loc[data_clean.weather_conditions == data_miss, 'weather_conditions'] = mode
    data_clean.drop(columns = 'Season', axis =1)
    data_clean.weather_conditions.value_counts()

    data_clean = data_clean.drop(columns={'Season'},axis=1)
    data_clean

    """**Effect before replacing missing data.**"""

    for (columnName,columnData) in data_clean.iteritems():
        if data_clean[columnName].dtypes == object:
            counts = data_clean[columnName].value_counts()
            print(columnName)
            # display(counts)

    for (columnName,columnData) in data_clean.iteritems():
        if data_clean[columnName].dtypes == np.object:
            data_clean[columnName] = data_clean[columnName].astype(str)

    for (columnName,columnData) in data_clean.iteritems():
        if data_clean[columnName].dtypes == object:
            # display(data_clean.junction_control.value_counts())
            print(columnName, data_clean.shape)
            missing = data_clean[data_clean[columnName].str.contains("missing", na=False)]
            print(len(missing)/len(data_clean))
            if len(missing)/len(data_clean)<0.03:
                # display(data_clean[columnName].str.contains("missing"))
                data_clean = data_clean[data_clean[columnName].str.contains("missing") == False]
            else:
                most_freq = data_clean[columnName].value_counts().index[0]
                data_clean.loc[data_clean[columnName].str.contains("missing"), columnName] = most_freq

    """**Effect after replacing missing data.**


    """

    for (columnName,columnData) in data_clean.iteritems():
        if data_clean[columnName].dtypes == object:
            counts = data_clean[columnName].value_counts()
            print(columnName)
            # display(counts)

    """## Findings and conclusions"""





    """## Observing outliers

    **Discovering Outliers in columns with IQR**
    """

    data_clean.info()

    # univariant
    data_description = data_clean.describe()
    column_names_outliers = []
    uppers = []
    lowers = []
    for (columnName, columnData) in data_description.iteritems():
        # if(columnName == "location_easting_osgr" or columnName == "location_northing_osgr" or columnName == "number_of_casualties"):
        #   continue
        min = data_clean[columnName].quantile(0)
        Q1 = data_clean[columnName].quantile(0.25)
        Q3 = data_clean[columnName].quantile(0.75)
        max = data_clean[columnName].quantile(1)
        IQR = Q3 - Q1
        cut_off = IQR * 1.5
        lower = Q1 - cut_off 
        if(lower < min):
            lower = min
        upper =  Q3 + cut_off
        if (upper >max):
            upper = max
        df1 = data_clean[data_clean[columnName]> upper]
        df2 = data_clean[data_clean[columnName]< lower]
        if(df1.shape[0]+ df2.shape[0]>2550):  #threshold 1%
            continue
        column_names_outliers.append(columnName)
        lowers.append(lower)
        uppers.append(upper) 
        print('Total number of outliers are', df1.shape[0]+ df2.shape[0])
        print(columnName ," ", upper , " " , lower)
    data_clean
    # multivariant

    """## Handling outliers

    **Removing Outliers discoverd by IQR**
    """

    # 255988
    for index,column_name in enumerate(column_names_outliers):
        print(index ," ", column_name)
        data_clean = data_clean[data_clean[column_name]<=uppers[index]]
        data_clean = data_clean[data_clean[column_name]>=lowers[index]]
    data_clean

    """**Remove Outliers with Z-score** """

    # 255729
    sns.kdeplot(data_clean["number_of_vehicles"])
    z = np.abs(stats.zscore(data_clean['number_of_vehicles']))
    z
    filtered_entries = z < 5
    filtered_entries
    data_clean = data_clean[filtered_entries]
    # print(data_clean.shape[0]-df_zscore_filter.shape[0])
    data_clean

    sns.kdeplot(data_clean["number_of_casualties"])


    z = np.abs(stats.zscore(data_clean['number_of_casualties']))
    z
    filtered_entries = z < 6
    filtered_entries
    data_clean = data_clean[filtered_entries]
    data_clean

    # 254753 
    # multivariate
    # fig, ax = plt.subplots(figsize=(16,8))
    # ax.scatter(data_clean['location_easting_osgr'], data_clean['location_northing_osgr'])
    # ax.set_xlabel('easting')
    # ax.set_ylabel('northing')
    # plt.show()
    data_clean = data_clean[data_clean.location_easting_osgr<700000]
    data_clean

    """# 4 - Data transformation"""

    data_clean

    """dropping features that consists of only unique values since it's not useful for analysis"""

    data_clean.info()

    columns_to_drop2=[]
    for (columnName, columnData) in data_clean.iteritems():
    
        if(data_clean[columnName].count() == data_clean[columnName].nunique()):
            columns_to_drop2.append(columnName)
    # print(len(columnName))
    print(columns_to_drop2)

    df_tr = data_clean.drop(columns= columns_to_drop2, axis=1)
    df_tr.info()

    """## 4.1 - Discretization

    Discretizing location_easting_osgr and location_northing_osgr
    """

    feature_count_pre = df_tr.shape[1]
    print("number of features orignially:",feature_count_pre)
    # display(df_tr[['location_easting_osgr', 'location_northing_osgr']])

    #first converting the features datatypes
    df_tr.location_easting_osgr = df_tr.location_easting_osgr.astype(np.float64)
    df_tr.location_northing_osgr = df_tr.location_northing_osgr.astype(np.float64)

    #binning
    df_tr.location_easting_osgr = pd.cut(df_tr.location_easting_osgr, bins=10, include_lowest = True, right=True, precision=0)
    df_tr.location_northing_osgr = pd.cut(df_tr.location_northing_osgr, bins=10, include_lowest = True, right=True, precision=0)
    print("number of features added:", df_tr.shape[1] - feature_count_pre)
    print("number of unique values of location_easting_osgr after binning:",df_tr.location_easting_osgr.nunique())
    print("number of unique values of location_northing_osgr after binning:",df_tr.location_northing_osgr.nunique())
    # display(df_tr[['location_easting_osgr', 'location_northing_osgr']])

    """Discretizing date into weeks"""

    df_tr['date'] = pd.to_datetime(df_tr["date"])
    feature_count_pre = df_tr.shape[1]
    print("before adding")


    #added feature
    df_tr['Week number'] = df_tr['date'].dt.isocalendar().week
    print("number of features added:", df_tr.shape[1] - feature_count_pre)
    #no features dropped
    print("number of features dropped:", 0)
    print("new feature is:\n")
    # display(df_tr[['date', 'Week number']])
    lookup_table_date = df_tr[['date', 'Week number']]

    """## 4.2 - Encoding
    **features to encode**

    one-hot \<=50 category per feature:
    
    1.   first_road_class, 6,
    2.   road_type, 4,
    3.   junction_detail, 9,
    4.   junction_control, 9, 
    5.   second_road_class, 7, 
    6.   pedestrian_crossing_human_control, 4, 
    7.   pedestrian_crossing_physical_facilities, 6, 
    8.   light_conditions, 5, 
    9.   weather_conditions, 8, 
    10.  road_surface_conditions, 5,
    11.  special_conditions_at_site, 6, 
    12.  carriageway_hazards, 6, 

    label encoding for features with >50 category per feature:
    1.   police_force, 51, 
    2.   local_authority_district, 461,
    3.   first_road_number, 3492, 
    4.   second_road_number, 2902,

    label encoding because it's an ordinal feature:
    1.   accident_severity, 3, ordinal encoding

    --------------------------------
    features to be encoded after creation:

    1.   map_area
    2.   season, one-hot
    --------------------------------
    Why we use one-hot encoding on these features? 
    - one-hot encoding is useful in features with a limited number of categories so as not to create tremendous amount of new features

    Why we use ordinal encoding in accident_severity feature?
    - accident severity has a natural ranking from slight(0) -> Fatal(2)

    Why we use one-hot encoding with most frequent on some features? 
    - to limit the number of new sparse features created

    one-hot encoding
    """

    features_to_one_hot_encode=[]
    for (columnName, columnData) in df_tr.select_dtypes(include=[object]).iteritems():
        if(df_tr[columnName].nunique() <=50):
            features_to_one_hot_encode.append(columnName)
    exclude= ['accident_severity']
    features_to_one_hot_encode = list(set(features_to_one_hot_encode) - set(exclude))
    features_to_one_hot_encode

    # features_to_one_hot_encode = [
    #     'first_road_class',
    #     'road_type',
    #     'junction_detail',
    #     'junction_control',
    #     'second_road_class',
    #     'pedestrian_crossing_human_control', 
    #     'pedestrian_crossing_physical_facilities',
    #     'light_conditions',
    #     'weather_conditions',
    #     'road_surface_conditions',
    #     'special_conditions_at_site',
    #     'carriageway_hazards',
    #                        ]
    feature_count_pre = df_tr.shape[1]
    print("number of features orignially:",feature_count_pre)
    # display(df_tr[features_to_one_hot_encode])
    df_encoded= pd.get_dummies(df_tr[features_to_one_hot_encode], drop_first = True)
    df_tr = pd.concat((df_tr,df_encoded), axis =1)
    print("number of features added:", df_tr.shape[1] - feature_count_pre)
    feature_count_pre = df_tr.shape[1]
    df_tr = df_tr.drop(axis =1, columns=features_to_one_hot_encode)
    print("number of features dropped:", -(df_tr.shape[1] - feature_count_pre))
    df_tr.head()

    """one-hot encoding with the most frequent classes"""

    #this method does one hot encoding for features based on percentage/number of the classes in the feature and drops the original feature
    def one_hot_top_n_percent_feature(df, feature, is_percent,limit_percent_with_max = False,  input_percent= 50, input_number=1):
        feature_count_pre = df.shape[1]
        # percent_covered = 0
        features_covered_n = input_number
        top_n_counts = df[feature].value_counts().sort_values(ascending=False).head(features_covered_n)
        percent_covered = top_n_counts.values.sum()*100/ df.shape[0]
        # print(features_covered_n, top_n_counts, percent_covered)
        if(top_n_counts.values.sum()<input_number):
            features_covered_n = top_n_counts
            top_n_counts = df[feature].value_counts().sort_values(ascending=False).head(features_covered_n)
            percent_covered = top_n_counts.values.sum()*100/ df.shape[0]
        else:
            while(percent_covered<input_percent):
                top_n_counts = df[feature].value_counts().sort_values(ascending=False).head(features_covered_n)
                percent_covered = top_n_counts.values.sum()*100/ df.shape[0]
                features_covered_n+=1
                if(limit_percent_with_max and features_covered_n == input_number):
                    break
        
            
        top_n_counts = df[feature].value_counts().sort_values(ascending=False).head(features_covered_n)
        top_n_labels = [x for x in top_n_counts.index]
        for label in top_n_labels:
            df[feature +"_"+ str(label)] = np.where(df[feature]==label,1,0)
            # df[[feature]+top_10_labels]
        print("number of features added:", df.shape[1] - feature_count_pre)
        print("percentage: ", top_n_counts.values.sum()*100/ df.shape[0], "%")
        del df[feature]

    def one_hot_top_n_percent_features(df, features, percent_to_cover, number_to_cover, is_percent = False, limit_percent_with_max= False):
        print("number of features orignially:", df.shape[1])
        for feature in features:
            one_hot_top_n_percent_feature(df, feature, is_percent= is_percent, limit_percent_with_max= limit_percent_with_max, input_percent=percent_to_cover, input_number=number_to_cover)
        print("number of features dropped:", len(features))

    """if 50 classes of the feature cover at least 80% of the observations then when use these classes, otherwise we increase the number of classes till they cover 80%"""

    features_to_label_encode=[]
    for (columnName, columnData) in df_tr.select_dtypes(include=[object]).iteritems():
        if(df_tr[columnName].nunique() >50):
            features_to_label_encode.append(columnName)
    exclude= ['time']
    features_to_label_encode = list(set(features_to_label_encode) - set(exclude))
    features_to_label_encode

    features_count=[]
    for columnName in features_to_label_encode:
        features_count.append(df_tr[columnName].value_counts())
    features_count

    df_copy_tr=df_tr.copy()
    def number_encode_features(df):
        result = df.copy() # take a copy of the dataframe
        for column in result.columns:
            if result.dtypes[column] == np.object: # if attribute is categorical
                # Apply LabelEncoder method to attribute
                # fit will infer the number of numerical values needed by counting the number of categories
                # then transform will replace each category with its numerical counterpart
                result[column] = preprocessing.LabelEncoder().fit_transform(result[column])
                df_tr[column]=result[column]
        return result
    # features_to_label_encode=['police_force', 'local_authority_district', 'first_road_number','second_road_number']
    print("Before Encoding \n")
    # display(df_tr[features_to_label_encode])
    number_encode_features(df_tr[features_to_label_encode])
    print("After Encoding \n")
    # display(df_tr[features_to_label_encode])

    """**mapping the encoded values to its original values**"""

    mapping_dict={}
    for i in range (len(features_count)):
        res = {features_count[i].index[j]: df_tr[features_to_label_encode[i]].value_counts().index[j] for j in range(len(features_count[i]))}
        mapping_dict[features_to_label_encode[i]]=res
    mapping_dict

    # It is not advised to one hot encode features with large number of categories
    # features_to_one_hot_most_freq_encode = ['police_force', 'local_authority_district', 'first_road_number','second_road_number']
    # one_hot_top_n_percent_features(df = df_tr,
    #                                features= features_to_one_hot_most_freq_encode,
    #                                percent_to_cover= 80,
    #                                number_to_cover= 50,
    #                                is_percent=True,
    #                                limit_percent_with_max= True)
    # df_tr.head()

    """label encoding for ordinal features"""

    feature_count_pre = df_tr.shape[1]
    print("number of features orignially:",feature_count_pre)

    features_to_label_encode = ['accident_severity']
    # display(df_tr[features_to_label_encode])
    mapping_schema = [{'Slight':0, 'Serious':1, 'Fatal':2}]

    for i,col in enumerate(features_to_label_encode):
    # display(df_tr[col].value_counts())
        df_tr[col] = df_tr[col].map(mapping_schema[i])

    feature_count_pre = df_tr.shape[1]

    print("number of features added:", df_tr.shape[1] - feature_count_pre)
    print("number of features dropped:", 0)
    # display(df_tr[features_to_label_encode])

    """## 4.3 - Normalisation

    Normalisation is making the data features follow a normal distribution. Since the goal of the Data engineering is unknown, we choose not to normalize. There's no current reason to use normalization, since the data is not, for example, fed to a model that uses normalized data

    ### Standardization

    Standardizing the features around the center and 0 with a standard deviation of 1 is important when we compare measurements that have different units. Variables that are measured at different scales do not contribute equally to the analysis and might end up creating a bais.

    For example, A variable that ranges between 0 and 1000 will outweigh a variable that ranges between 0 and 1. Using these variables without standardization will give the variable with the larger range weight of 1000 in the analysis. We use standardization to combat this effect

    we Standardize based on the value of std of the features, and we chose the threshhold to be an arbitrary value 20 since using threshold =10 standardized columns with small ranges like speed_limit and minutes. it doesn't make since to standardize the location features besides we're using them anyway in creating a new feature so we left them out.

    we normalize all the numerical features in the data set. why? to prevent making the feature scale affect the analysis model when the scales of features are very different and apart
    """

    # for column in df_tr:
    features_to_standardize=[]
    Exceptions = ['location_easting_osgr', 'location_northing_osgr']
    for column in df_tr.select_dtypes(include=[np.number]):
        std = df_tr[column].std()
        if(std>40):
            features_to_standardize.append(column)
    features_to_standardize = set(features_to_standardize) - set(Exceptions)
    print(list(features_to_standardize))
    for feature in features_to_standardize:
        df_tr[feature] = (df_tr[feature] - df_tr[feature].mean()) / (df_tr[feature].std())

    df_tr[features_to_standardize]

    """## 4.4 - Adding more columns

    area column
    """

    #adding the area feature
    df_tr["area"] = df_tr.location_northing_osgr.astype(str) +"_"+ df_tr.location_easting_osgr.astype(str)

    feature_count_pre = df_tr.shape[1]


    print("number of unique values of the area feature:",df_tr.area.nunique())

    #we drop the the location_easting_osgr and location_northing_osgr
    df_tr = df_tr.drop(axis =1, columns=['location_easting_osgr', 'location_northing_osgr'])
    print("number of features dropped:", -(df_tr.shape[1] - feature_count_pre))
    print("new features are: \n")
    df_tr[['area']].head()

    """adding features season, month, day, hour and minutes
    note: ideally these added features should be processed but we leave them as is due to the order of the notebook operations
    """

    def season_of_date(date):
        doy = date.dayofyear
        # "day of year" ranges for the northern hemisphere
        spring = range(80, 172)
        summer = range(172, 264)
        fall = range(264, 355)
        # winter = everything else
        if doy in spring:
            return 'spring'
        elif doy in summer:
            return 'summer'
        elif doy in fall:
            return 'fall'
        else:
            return 'winter'

    feature_count_pre = df_tr.shape[1]
    print("number of features orignially:",feature_count_pre)

    #adding featured
    df_tr['month'] = df_tr['date'].dt.month
    df_tr['day_of_month'] = df_tr['date'].dt.day
    df_tr['hour'] = pd.to_datetime(df_tr['time'], format='%H:%M').dt.hour
    df_tr['minute'] = pd.to_datetime(df_tr['time'], format='%H:%M').dt.minute
    df_tr['season'] = df_tr['date'].map(season_of_date)
    print("number of features added:", df_tr.shape[1] - feature_count_pre)
    feature_count_pre = df_tr.shape[1]

    #dropping features
    df_tr = df_tr.drop(axis =1, columns=['date', 'time'])
    print("number of features dropped:", -(df_tr.shape[1] - feature_count_pre))
    print("new features are: \n")
    df_tr[['season', 'month','day_of_month', 'hour', 'minute']].head()

    """## 4.5 - Csv file for lookup"""

    additional_mapping=[['first_road_number','first_road_class is C or Unclassified. These roads do not have official numbers so recorded as zero ',"0.0"],
    ['second_road_class','-1','Unavailable'],
    ['second_road_number','first_road_class is C or Unclassified. These roads do not have official numbers so recorded as zero ','0.0'],
    ['accident_severity','Slight','0'],
    ['accident_severity','Serious','1'],
    ['accident_severity','Fatal','2'],]

    csv_file = lookup_table_output_path
    try:
        with open(csv_file, 'w') as csvfile:
            date =  datetime(1990, 1, 1)
            writer = csv.writer(csvfile)
            writer.writerow(["column_name","old_value","new_value"])
            for i in range(0,52):
                date_string = date.strftime('%m/%d/%Y')
                row_data = ["date",date_string,i+1]
                date =  date + timedelta(days=7)
                writer.writerow(row_data)
            for key in mapping_dict:
                for key2 in mapping_dict[key]:
                    row_data = [key,key2,mapping_dict[key][key2]]
                    writer.writerow(row_data)
            for row in additional_mapping:
                writer.writerow(row)
    except IOError:
        print("I/O error")

    """## 5- Exporting the dataframe to a csv file or parquet"""

    # df_tr.to_csv('data/1990_Accidents_UKCleaned.csv', index=False)
    df_tr.to_csv(cleaned_data_output_path, index=False)











def milestone2(cleaned_data_path, additional_data_path, integrated_data_output_path ,lookup_table_output_path):
    # !pip install kaggle

    # ! mkdir ~/.kaggle

    # ! cp kaggle.json ~/.kaggle/

    # """**this is the api token for my kaggle account, upload your kaggle token to access the dataset**"""

    # ! chmod 600 ~/.kaggle/kaggle.json

    # ! kaggle datasets download -d keithcooper/uk-road-safety-dataset-1979-2020

    # ! unzip uk-road-safety-dataset-1979-2020

    # ! rm uk-road-safety-dataset-1979-2020.zip
    # ! rm dft-road-casualty-statistics-casualty-1979-2020.csv
    # ! rm dft-road-casualty-statistics-accident-1979-2020.csv
    # ! rm Understanding-historical-road-safety-data.docx
    # ! rm Road-Safety-Open-Dataset-Data-Guide.xlsx

    # df_tr = pd.read_csv('data/1990_Accidents_UK_milestone1.csv')
    df_tr = pd.read_csv(cleaned_data_path)
    # path = 'dft-road-casualty-statistics-vehicle-1979-2020.csv'
    # path = additional_data_path
    # index_col = "accident_index"
    # df_additional = pd.read_csv(path, index_col=index_col)

    # df_additional.shape

    # df_additional = df_additional.loc[(df_additional['accident_year'] == 1990)]

    # df_additional.shape

    # """we only need these 2 features"""

    # df_additional = df_additional[['age_of_driver' , 'vehicle_reference']]

    # df_additional = df_additional[df_additional['vehicle_reference'] == 1]

    # df_additional = df_additional.drop(['vehicle_reference'], axis=1)

    # df_additional.head()

    """-----------------------------------------"""

    # imported_ds_path = '/content/file1.csv' # No clue (dumb path)
    # path2 = '/content/drive/MyDrive/file1.csv' # Mahmoud
    # path2 = '/content/file1.csv'#ali
    # df_accidents_drivers = pd.read_csv(imported_ds_path, index_col=index_col)
    # df_additional = df_additional[df_additional['vehicle_reference'] == 1]
    # df_additional = df_additional.drop(['vehicle_reference'], axis=1)

    df_additional = pd.read_csv(additional_data_path)
    df_new = pd.merge( df_tr , df_additional , left_index=True , right_index=True)

    df_new.info()

    df_new.shape

    df_new.age_of_driver

    """Percentage of data that has -1 in age of driver feature"""

    len(df_new[df_new.age_of_driver == -1])/len(df_new)*100

    """Percentage of data that is null in age of driver feature"""

    df_new.age_of_driver.isnull().sum()/len(df_new)*100

    """viewing observations where age of driver =-1"""

    df_new[df_new.age_of_driver==-1]

    """**Clean the age_of_driver**

    before cleaning
    """

    # display(df_new.age_of_driver.value_counts())
    df_new

    """after cleaning"""

    df_new=df_new[df_new['age_of_driver']!=-1]
    df_new

    df_new.age_of_driver.value_counts()

    sns.kdeplot(df_new['age_of_driver'])
    # z = np.abs(stats.zscore(df_new['age_of_driver']))
    # sns.kdeplot(z)
    # z

    df_new

    df_new_outliers = df_new[df_new['age_of_driver'].between(10,80)]

    df_new_outliers

    """Binning the age of driver feature using equal frequency binning"""

    # Qcut method in pandas
    age_encode_array = ["Teens", "Youth","Adults","Elderly"]
    Age_disccretised, intervals = pd.qcut(
        df_new_outliers['age_of_driver'], 4, labels=age_encode_array, retbins=True, precision=3, duplicates='raise')

    # retrieve 1st 10 rows
    df_new_outliers['life_stage'] = Age_disccretised

    # df_new_outliers = pd.concat([df_new_outliers, Age_disccretised], axis=1)
    # df_new_outliers

    """viewing the feature before and after binning together"""

    df_new_outliers[["age_of_driver", "life_stage"]]

    df_complete = df_new_outliers.drop(labels = ["age_of_driver"], axis=1)

    lookup = {}
    for i in range(4):
        interval = "{" +str(intervals[i]) + "," +str(intervals[i+1]) + "}"
        lookup[age_encode_array[i]] =interval
    lookup
    # csv_file = 'lookup_tables.csv'
    csv_file = lookup_table_output_path
    try:
        with open(csv_file, 'a') as csvfile:
            writer = csv.writer(csvfile)
            for key in lookup:
                row_data = ["age_of_driver",lookup[key],key]
                writer.writerow(row_data)
    except IOError:
        print("I/O error")

    """## Question 1

    **Which life stage is involved in most accidents?**
    Answer: teens

    **Visualization**
    """

    # chart = sns.countplot(x ='life_stage', data = df_complete)
    # plt.xlabel("life stage")
    # plt.ylabel("number of accidents")
    # plt.show(chart)
    # print(df_complete.life_stage.value_counts().index[0])
    # df_complete.life_stage.value_counts().max()

    """## Question 2
    **What is the realtion between the life stage of vehicle drivers present in the accidents and week number?**
    Answer: Teens have the most accidents from weeks 12 to 42, while the elderly have the most accidents from the beginning of the year to week 12, and from week 42 till the end of the year.
    """

    # sns.FacetGrid(df_complete, size=5, hue="life_stage").map(sns.distplot, "Week number").add_legend()

    # df_complete.to_csv('additional_data.csv', index=False)
    df_complete.to_csv(integrated_data_output_path, index=False)